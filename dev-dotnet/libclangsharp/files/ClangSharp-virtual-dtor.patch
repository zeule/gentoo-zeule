commit 51c0e95e97e73080e3e0319ead9b85aeec1f8d12
Author: Eugene Shalygin <eugene.shalygin@gmail.com>
Date:   Fri Jun 25 15:02:18 2021 +0200

    Handle virtual destructors in C++ classes
    
    This resolves crashing on virtual destructors if Clang is build with
    assertions and corrects vtbl indices for tables with destructors.
    
    Fixes #240.

diff --git a/sources/libClangSharp/ClangSharp.cpp b/sources/libClangSharp/ClangSharp.cpp
index 3a134e7..9c8ef35 100644
--- a/sources/libClangSharp/ClangSharp.cpp
+++ b/sources/libClangSharp/ClangSharp.cpp
@@ -4693,23 +4693,51 @@ CXCursor clangsharp_Cursor_getVBase(CXCursor C, unsigned i) {
     return clang_getNullCursor();
 }
 
-int64_t clangsharp_Cursor_getVtblIdx(CXCursor C) {
+namespace {
+    int64_t getVtblIdx(const GlobalDecl& d)
+    {
+        const CXXMethodDecl* CMD = static_cast<const CXXMethodDecl*>(d.getDecl());
+        if (VTableContextBase::hasVtableSlot(CMD)) {
+            VTableContextBase* VTC = CMD->getASTContext().getVTableContext();
+
+            if (MicrosoftVTableContext* MSVTC = dyn_cast<MicrosoftVTableContext>(VTC)) {
+                MethodVFTableLocation ML = MSVTC->getMethodVFTableLocation(d);
+                return ML.Index;
+            }
+
+            if (ItaniumVTableContext* IVTC = dyn_cast<ItaniumVTableContext>(VTC)) {
+                return IVTC->getMethodVTableIndex(d);
+            }
+        }
+
+        return -1;
+    }
+}
+
+int64_t clangsharp_Cursor_getDtorVtblIdx(CXCursor C, CX_DestructorType dtor)
+{
     if (isDeclOrTU(C.kind)) {
         const Decl* D = getCursorDecl(C);
 
-        if (const CXXMethodDecl* CMD = dyn_cast<CXXMethodDecl>(D)) {
-            if (VTableContextBase::hasVtableSlot(CMD)) {
-                VTableContextBase* VTC = getASTUnit(getCursorTU(C))->getASTContext().getVTableContext();
+        if (const CXXDestructorDecl* CMD = dyn_cast<CXXDestructorDecl>(D)) {
+            return getVtblIdx(GlobalDecl(CMD, dtor));
+        }
+    }
+    return -1;
+}
 
-                if (MicrosoftVTableContext* MSVTC = dyn_cast<MicrosoftVTableContext>(VTC)) {
-                    MethodVFTableLocation ML = MSVTC->getMethodVFTableLocation(CMD);
-                    return ML.Index;
-                }
+int64_t clangsharp_Cursor_getVtblIdx(CXCursor C) {
+    if (isDeclOrTU(C.kind)) {
+        const Decl* D = getCursorDecl(C);
 
-                if (ItaniumVTableContext* IVTC = dyn_cast<ItaniumVTableContext>(VTC)) {
-                    return IVTC->getMethodVTableIndex(CMD);
-                }
+        if (const CXXMethodDecl* CMD = dyn_cast<CXXMethodDecl>(D)) {
+            int64_t dtorIdx = clangsharp_Cursor_getDtorVtblIdx(C, Deleting); // will test if CMD is a dtor
+            if (dtorIdx != -1) { // yes, it is a dtor
+                return dtorIdx;
             }
+
+            // no, it is a regular method
+            return getVtblIdx(CMD);
         }
     }
 
diff --git a/sources/libClangSharp/ClangSharp.h b/sources/libClangSharp/ClangSharp.h
index 9a018a9..5363f35 100644
--- a/sources/libClangSharp/ClangSharp.h
+++ b/sources/libClangSharp/ClangSharp.h
@@ -202,6 +202,13 @@ enum CX_VariableCaptureKind {
     CX_VCK_VLAType = clang::CapturedStmt::VCK_VLAType + 1
 };
 
+enum CX_DestructorType {
+    Deleting = clang::Dtor_Deleting,
+    Complete = clang::Dtor_Complete,
+    Base = clang::Dtor_Base,
+    Comdat = clang::Dtor_Comdat
+};
+
 struct CX_TemplateArgument {
     CXTemplateArgumentKind kind;
     int xdata;
@@ -722,6 +729,8 @@ CLANGSHARP_LINKAGE CXCursor clangsharp_Cursor_getUsedContext(CXCursor C);
 
 CLANGSHARP_LINKAGE CXCursor clangsharp_Cursor_getVBase(CXCursor C, unsigned i);
 
+CLANGSHARP_LINKAGE int64_t clangsharp_Cursor_getDtorVtblIdx(CXCursor C, CX_DestructorType dtor);
+
 CLANGSHARP_LINKAGE int64_t clangsharp_Cursor_getVtblIdx(CXCursor C);
 
 CLANGSHARP_LINKAGE void clangsharp_TemplateArgument_dispose(CX_TemplateArgument T);
